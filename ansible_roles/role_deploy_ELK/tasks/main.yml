---

- name: retrieve the elasticsearch_token
  slurp:
       src: /home/ubuntu/elasticsearch_token
  register: elastic_token
  
- name: Starting kibana autoconfiguration
  command: "/usr/share/kibana/bin/kibana-setup"
  args:
        stdin: "{{ elastic_token.content | b64decode }}"

- name: restart_kibana
  shell: systemctl restart kibana.service
  
- name: restart_logstash
  shell: systemctl restart logstash.service


- name: Generate the 3 keys
  shell: |
        /usr/share/kibana/bin/kibana-encryption-keys generate --force | grep -A 3 "Settings:" | grep -v "Settings:" > /home/ubuntu/params_xpack
        chmod 600 /home/ubuntu/params_xpack
- name: retrieve the keys with xpack params
  slurp:
       src: /home/ubuntu/params_xpack
  register: params_xpack

- name: Inserting params
  lineinfile:
      path: /etc/kibana/kibana.yml
      line: "{{ params_xpack.content | b64decode }}"
      insertafter: EOF



# Changing elastic password and saving it in the current directory for later use in 600 mode
- name: Chaning elastic password
  shell: |
     yes | sudo /usr/share/elasticsearch/bin/elasticsearch-reset-password -u elastic | grep -oP 'New value: \K.*' > /home/ubuntu/elastic_pw
     
    # This is another method for the regex parsing
    # '/New value:/ {print $NF}' output.txt
    #  sed -n 's/New value: //p' output.txt
- name: retrieve the elastic_pw value
  slurp:
       src: /home/ubuntu/elastic_pw
  register: elastic_pw_val

# Managing the keystore for secure rest //// Another way to setup passwords without changing the elasticsearch parameters in kibana  /// this should be done after token enrollment
# Don't use a privileged user like elastic
#- name: Creating a keystore for the stores
#  shell: /usr/share/kibana/bin/kibana-keystore create
#- name: Adding Keystore with the exact parameter name in kibana.yml
#  command: "/usr/share/kibana/bin/kibana-keystore add elasticsearch.username"
#  args:
#        stdin: "elastic"
#- name: Adding Keystore with the exact parameter name in kibana.yml
#  command: "/usr/share/kibana/bin/kibana-keystore add elasticsearch.password"
#  args:
#        stdin: "{{ elastic_pw_val.content | b64decode }}"

#=========================================================



# Advanced parameters used when we have a reverse proxy infront kibana
# The elasticsearch parameter server.rewriteBasePath set to true when we have the server.basePath has a value in kibana.yml, used to tell Kibana if it should remove the basePath from requests it receives, and to prevent a deprecation warning at startup.

#- name: Configuring Kibana conf to handle the reverse proxy requests {server.basePath}
#  lineinfile:
#      path: /etc/kibana/kibana.yml
#      regex: '^#server.basePath:'
#      line: 'server.basePath: "/login"'

#- name: Configuring Kibana conf to handle the reverse proxy requests {server.rewriteBasePath}
#  lineinfile:
#        path: /etc/elasticsearch/elasticsearch.yml
#        line: "server.rewriteBasePath: true"
#        insertafter: EOF
#  notify: restart_kibana


# Configurations needed for single-node deployment
#
#
#
- name: Setting up number_of_replicas to 0 via API call
  shell: |
       curl -k -H "Content-Type: application/json" -XPUT https://localhost:9200/*/_settings -d '{ "index" : { "number_of_replicas" : 0 } }' -u elastic:"{{ elastic_pw_val.content | b64decode }}"
  register: curl_res
- name: Printing results
  debug:
     var: curl_res.stdout_lines


# Directory layout
#
#
#

# Nginx deployment
#
#
#
- name: Installing NGINX Webserver
  apt:
      name:
         - nginx
         - certbot
         - python3-certbot-nginx
      state: latest
      
- name: Copy and render Nginx configuration file
  template:
        src: role_deploy_ELK/templates/default.j2
        dest: /etc/nginx/sites-available/default
        mode: '0644'

- name: Securing nginx with additional header layers of security
  template:
        src: role_deploy_ELK/templates/nginx.j2
        dest: /etc/nginx/nginx.conf
        mode: '0644'
#- name: Deploying SSL certificate to NGINX via certbot tool
#  shell : |
#       certbot --nginx -d ansi-elk.duckdns.org -d www.ansi-elk.duckdns.org
- name: Run Certbot
  command: certbot --non-interactive --register-unsafely-without-email --nginx -d ansi-elk.duckdns.org -d www.ansi-elk.duckdns.org --agree-tos 


- name: Deploying a cron job for certificate renewal { Let's encrypt }
  cron:
      name: Let's encrypt SSL Certificate Renewal
      state: present
      user: root
      minute: '0'
      hour: '12'
      day: '*'
      weekday: '*'
      month: '*'
      job: /usr/bin/certbot renew --quiet

# To fix the redirection from ip to domain name ======> Only when port 80 is open
#- name: Fixing and redirecting the traffic from IpAddress to Domain name
#  lineinfile:
#        path: /etc/nginx/sites-available/default
#        insertafter: '} # managed by Certbot'
#        block: |
            # Redirect IP addresses to the domain name
#            if ($host ~* "^\d+\.\d+\.\d+\.\d+$") {
#            return 301 https://info-association.duckdns.org$request_uri;
#            }
